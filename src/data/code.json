{
  "typescript": {
    "filename": "main.tsx",
    "code": "import { createSignal, createEffect } from \"solid-js\";\nimport type { ColorScheme } from \"./types\";\n\ninterface AppProps {\n  initialScheme?: ColorScheme;\n}\n\nexport default function App(props: AppProps) {\n  const [scheme, setScheme] = createSignal<ColorScheme>(\n    props.initialScheme ?? defaultColorScheme\n  );\n\n  createEffect(() => {\n    localStorage.setItem('scheme', JSON.stringify(scheme()));\n  });\n\n  return (\n    <div class=\"app\">\n      <Preview scheme={scheme()} />\n    </div>\n  );\n}"
  },
  "javascript": {
    "filename": "main.js",
    "code": "import { createSignal } from \"solid-js\";\n\nfunction createColorScheme(name, colors) {\n  return {\n    name,\n    ...colors,\n    createdAt: new Date()\n  };\n}\n\nfunction App() {\n  const [scheme, setScheme] = createSignal(defaultColorScheme);\n\n  const handleColorChange = (key, value) => {\n    setScheme(prev => ({ ...prev, [key]: value }));\n  };\n\n  return <Preview scheme={scheme()} />;\n}"
  },
  "python": {
    "filename": "main.py",
    "code": "from typing import Dict, List, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass ColorScheme:\n    background: str\n    foreground: str\n    red: str\n    green: str\n\n    def to_dict(self) -> Dict[str, str]:\n        return {\n            \"background\": self.background,\n            \"foreground\": self.foreground,\n        }\n\ndef create_default_scheme() -> ColorScheme:\n    return ColorScheme(\n        background=\"#0c0c0c\",\n        foreground=\"#cccccc\"\n    )"
  },
  "rust": {
    "filename": "main.rs",
    "code": "use std::collections::HashMap;\n\n#[derive(Debug, Clone)]\npub struct ColorScheme {\n    pub background: String,\n    pub foreground: String,\n    pub red: String,\n}\n\nimpl ColorScheme {\n    pub fn new() -> Self {\n        Self {\n            background: \"#0c0c0c\".to_string(),\n            foreground: \"#cccccc\".to_string(),\n            red: \"#cd3131\".to_string(),\n        }\n    }\n\n    pub fn to_hashmap(&self) -> HashMap<String, String> {\n        let mut map = HashMap::new();\n        map.insert(\"background\".to_string(), self.background.clone());\n        map\n    }\n}"
  },
  "go": {
    "filename": "main.go",
    "code": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype ColorScheme struct {\n    Background string `json:\"background\"`\n    Foreground string `json:\"foreground\"`\n    Red        string `json:\"red\"`\n}\n\nfunc NewColorScheme() *ColorScheme {\n    return &ColorScheme{\n        Background: \"#0c0c0c\",\n        Foreground: \"#cccccc\",\n        Red:       \"#cd3131\",\n    }\n}\n\nfunc (cs *ColorScheme) ToJSON() ([]byte, error) {\n    return json.Marshal(cs)\n}"
  },
  "c": {
    "filename": "main.c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char* background;\n    char* foreground;\n    char* red;\n} ColorScheme;\n\nColorScheme* create_color_scheme(const char* bg, const char* fg) {\n    ColorScheme* scheme = malloc(sizeof(ColorScheme));\n    scheme->background = strdup(bg);\n    scheme->foreground = strdup(fg);\n    return scheme;\n}\n\nint main(void) {\n    ColorScheme* scheme = create_color_scheme(\"#0c0c0c\", \"#cccccc\");\n    printf(\"Background: %s\\n\", scheme->background);\n    free(scheme->background);\n    free(scheme);\n    return 0;\n}"
  },
  "cpp": {
    "filename": "main.cpp",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n\nclass ColorScheme {\nprivate:\n    std::string background;\n    std::string foreground;\n\npublic:\n    ColorScheme(const std::string& bg, const std::string& fg)\n        : background(bg), foreground(fg) {}\n\n    std::map<std::string, std::string> to_map() const {\n        std::map<std::string, std::string> result;\n        result[\"background\"] = background;\n        result[\"foreground\"] = foreground;\n        return result;\n    }\n};\n\nint main() {\n    ColorScheme scheme(\"#0c0c0c\", \"#cccccc\");\n    std::cout << \"Background: \" << scheme.to_map()[\"background\"] << std::endl;\n    return 0;\n}"
  },
  "zig": {
    "filename": "main.zig",
    "code": "const std = @import(\"std\");\n\nconst ColorScheme = struct {\n    background: []const u8,\n    foreground: []const u8,\n    red: []const u8,\n\n    pub fn toMap(self: ColorScheme, allocator: std.mem.Allocator) !std.StringHashMap([]const u8) {\n        var map = std.StringHashMap([]const u8).init(allocator);\n        try map.put(\"background\", self.background);\n        try map.put(\"foreground\", self.foreground);\n        return map;\n    }\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const scheme = ColorScheme{\n        .background = \"#0c0c0c\",\n        .foreground = \"#cccccc\",\n    };\n    const map = try scheme.toMap(allocator);\n    std.debug.print(\"Background: {s}\\n\", .{scheme.background});"
  }
}
